package Sort_hw;

public class BubbleSort {
	
	public static void main(String[] args) {
		// ture : 오름차순, false : 내림차순
		int[] a = { 2, 12, 7, 6, 5, 17, 3 };
		bubblesort(true, a);
		for (int i : a) {
			System.out.print(i + " ");
		}
	}

	public static void bubblesort(boolean isAscending, int... num) {
		int temp;
		if (isAscending) {	//오름차순
			for (int i = 0; i < num.length; i++) {	//i는 배열 전체를 1회 연달아 위치한 요소값을 비교
				for (int j = 0; j < num.length - 1; j++) {	//이 for문은 하나씩 제자리를 찾은
					                                        //마지막 요소 값을 하나씩 빼고 순환되도록 함.
					if (num[j] > num[j + 1]) {	//j번 요소값이 j+1번 요소값 보다 클 경우,
						temp = num[j];		//j번 요소를 temp로 빼내고
						num[j] = num[j + 1];	//j+1번의 작은 요소값을 j번에 넣는다.
						num[j + 1] = temp;	//빼놓았던 원래 j번에 있던 큰 요소값은 temp에서 꺼내어 j+1에 넣는다.
					}
				}
			}
		} else {	//내림차순 (오름 차순과 동일한 처리 과정)
			for (int i = 0; i < num.length; i++) {
				for (int j = 0; j < num.length - 1; j++) {
					if (num[j] < num[j + 1]) {
						temp = num[j];
						num[j] = num[j + 1];
						num[j + 1] = temp;
					}
				}
			}
		}
	}
}

// 버블 정렬 (Bubble Sort) - 나무위키(https://namu.wiki/w/%EC%A0%95%EB%A0%AC%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98#s-2.1.1)
// 1번째와 2번째 원소를 비교하여 정렬하고, 2번째와 3번째, ..., n-1번째와 n번째를 정렬한 뒤
// 다시 처음으로 돌아가 이번에는 n-2번째와 n-1번째까지, ...해서 최대 {n(n-1)}/2 번 정렬한다.
// 한 번 돌 때마다 마지막 하나가 정렬되므로 원소들이 거품이 올라오는 것처럼 보여 거품정렬이다.

// 거의 모든 상황에서 최악의 성능을 보여준다.
// 단, 이미 정렬된 자료에서는 1번만 돌면 되기 때문에 최선의 성능을 보여준다.
// 이미 정렬된 자료를 정렬하는 바보짓을 왜 하냐는 의문이 들 수 있지만, 정렬 알고리즘은 자료가 정렬되어 있는지 아닌지는 모르고 작동하기 때문에 의미가 있다.
// 가장 손쉽게 구현하여 사용할 수 있지만, 만들기가 쉽고 직관적일 뿐이지 알고리즘적 관점에서 보면 대단히 비효율적인 정렬 방식이다.
// 다른 몇 가지 정렬 방식과 비교해도 효율이 대략 시망.

// 이해하기 쉽고 코드가 짧은 덕에 각종 교습서에서 정렬 알고리즘의 예시로 많이 보여주며,
// 입력량이 작으면 어지간한 비효율적인 방법도 씹어먹고 수행이 가능하지만 실제 개발에서는 전혀 쓰이지 않는다고 봐도 무방하다.
// 정말 어지간한 경우가 아닌 이상 버블 소트는 피해야 한다.
// 요즘은 웬만한 프로그래밍 언어 내부에 온갖 꼼수를 다 갈아넣은 고효율의 정렬 알고리즘이 내장되어 있어,
// 그냥 인클루드해서 갖다 쓰기만 하면 되는 세상이라 버블 정렬의 장점이 거의 없다. 내장 정렬이 더 편하니...
